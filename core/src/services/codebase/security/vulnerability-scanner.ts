/**
 * Vulnerability Scanner Service
 * 
 * Comprehensive vulnerability scanning service that integrates with multiple
 * security databases (OSV, GitHub Security Advisories, Snyk) to identify
 * known security vulnerabilities in project dependencies.
 */

import axios from 'axios';
import { DatabaseManager } from '../../../utils/database.js';
import type {
  Vulnerability,
  VulnerabilitySeverity,
  VulnerabilityScanResult,
  SupportedLanguage,
  RiskLevel
} from '../../../shared/types/codebase.js';

export interface SecurityConfig {
  osvApiUrl?: string;
  githubToken?: string;
  snykToken?: string;
  cacheTimeout?: number; // in milliseconds
  requestTimeout?: number; // in milliseconds
  maxRetries?: number;
  rateLimitDelay?: number; // in milliseconds
}

export interface PackageInfo {
  name: string;
  version: string;
  language: SupportedLanguage;
}

export interface VulnerabilityResult {
  package: PackageInfo;
  vulnerabilities: Vulnerability[];
  scanTime: number;
  source: string;
}

export interface RepositoryScanResult {
  repositoryId: string;
  totalPackages: number;
  packagesScanned: number;
  vulnerabilities: Vulnerability[];
  summary: {
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
    infoCount: number;
  };
  scanDuration: number;
  sources: string[];
}

export interface Advisory {
  id: string;
  summary: string;
  description: string;
  severity: VulnerabilitySeverity;
  publishedAt: string;
  updatedAt: string;
  references: string[];
  cvss?: number;
}

export interface SnykVulnerability {
  id: string;
  title: string;
  description: string;
  severity: VulnerabilitySeverity;
  cvssScore?: number;
  references: string[];
  semver?: {
    vulnerable: string[];
    unaffected?: string[];
  };
}

export interface CVSSScore {
  version: string;
  vectorString: string;
  baseScore: number;
  baseSeverity: VulnerabilitySeverity;
  temporalScore?: number;
  environmentalScore?: number;
}

export interface PrioritizedVulnerability extends Vulnerability {
  priority: number;
  risk: RiskLevel;
  recommendation: string;
}

export class VulnerabilityScanner {
  private readonly config: Required<SecurityConfig>;
  private readonly osvCache = new Map<string, { data: any; timestamp: number }>();
  private readonly githubCache = new Map<string, { data: any; timestamp: number }>();
  private readonly snykCache = new Map<string, { data: any; timestamp: number }>();

  constructor(
    private db: DatabaseManager,
    config: SecurityConfig = {}
  ) {
    this.config = {
      osvApiUrl: config.osvApiUrl || 'https://api.osv.dev',
      githubToken: config.githubToken || process.env.GITHUB_TOKEN || '',
      snykToken: config.snykToken || process.env.SNYK_TOKEN || '',
      cacheTimeout: config.cacheTimeout || 3600000, // 1 hour
      requestTimeout: config.requestTimeout || 30000, // 30 seconds
      maxRetries: config.maxRetries || 3,
      rateLimitDelay: config.rateLimitDelay || 1000 // 1 second
    };
  }

  /**
   * Scan a single package for vulnerabilities
   */
  async scanPackage(packageName: string, version: string, language: SupportedLanguage): Promise<Vulnerability[]> {
    const startTime = Date.now();
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Query OSV database
      const osvVulns = await this.queryOSVDatabase(packageName, version);
      vulnerabilities.push(...osvVulns);

      // Query GitHub Security Advisories if token available
      if (this.config.githubToken) {
        const githubAdvisories = await this.queryGitHubAdvisories(packageName);
        const githubVulns = await this.convertAdvisoriesToVulnerabilities(
          githubAdvisories,
          packageName,
          version
        );
        vulnerabilities.push(...githubVulns);
      }

      // Query Snyk database if token available
      if (this.config.snykToken) {
        const snykVulns = await this.querySnykDatabase(packageName, version);
        const convertedSnykVulns = await this.convertSnykToVulnerabilities(
          snykVulns,
          packageName,
          version
        );
        vulnerabilities.push(...convertedSnykVulns);
      }

      // Deduplicate based on CVE ID or vulnerability ID
      const deduplicatedVulns = this.deduplicateVulnerabilities(vulnerabilities);

      // Store scan results in database
      await this.storeScanResults(packageName, version, language, deduplicatedVulns);

      return deduplicatedVulns;
    } catch (error) {
      console.error(`Error scanning package ${packageName}@${version}:`, error);
      throw error;
    }
  }

  /**
   * Scan multiple packages in batch
   */
  async batchScanPackages(packages: PackageInfo[]): Promise<VulnerabilityResult[]> {
    const results: VulnerabilityResult[] = [];
    const batchSize = 5; // Process 5 packages at a time to avoid rate limits

    for (let i = 0; i < packages.length; i += batchSize) {
      const batch = packages.slice(i, i + batchSize);
      const batchPromises = batch.map(async (pkg) => {
        const startTime = Date.now();
        try {
          const vulnerabilities = await this.scanPackage(pkg.name, pkg.version, pkg.language);
          return {
            package: pkg,
            vulnerabilities,
            scanTime: Date.now() - startTime,
            source: 'batch-scan'
          } as VulnerabilityResult;
        } catch (error) {
          console.error(`Failed to scan ${pkg.name}@${pkg.version}:`, error);
          return {
            package: pkg,
            vulnerabilities: [],
            scanTime: Date.now() - startTime,
            source: 'batch-scan-error'
          } as VulnerabilityResult;
        }
      });

      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults);

      // Rate limiting delay between batches
      if (i + batchSize < packages.length) {
        await this.delay(this.config.rateLimitDelay);
      }
    }

    return results;
  }

  /**
   * Scan entire repository for vulnerabilities
   */
  async scanRepository(repositoryId: string): Promise<RepositoryScanResult> {
    const startTime = Date.now();

    try {
      // Get all packages from dependency graph
      const packages = await this.getRepositoryPackages(repositoryId);
      
      // Scan all packages
      const results = await this.batchScanPackages(packages);
      
      // Aggregate vulnerabilities
      const allVulnerabilities = results.flatMap(r => r.vulnerabilities);
      const summary = this.calculateSummary(allVulnerabilities);

      const scanResult: RepositoryScanResult = {
        repositoryId,
        totalPackages: packages.length,
        packagesScanned: results.length,
        vulnerabilities: allVulnerabilities,
        summary,
        scanDuration: Date.now() - startTime,
        sources: [...new Set(results.map(r => r.source))]
      };

      // Store repository scan summary
      await this.storeRepositoryScanResult(scanResult);

      return scanResult;
    } catch (error) {
      console.error(`Error scanning repository ${repositoryId}:`, error);
      throw error;
    }
  }

  /**
   * Query OSV database for vulnerabilities
   */
  async queryOSVDatabase(packageName: string, version: string): Promise<Vulnerability[]> {
    const cacheKey = `osv-${packageName}-${version}`;
    
    // Check cache first
    const cached = this.osvCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.config.cacheTimeout) {
      return cached.data;
    }

    try {
      const response = await axios.post(
        `${this.config.osvApiUrl}/v1/query`,
        {
          package: {
            name: packageName,
            ecosystem: this.getOSVEcosystem(packageName)
          },
          version
        },
        {
          timeout: this.config.requestTimeout,
          headers: {
            'Content-Type': 'application/json'
          }
        }
      );

      const vulnerabilities = await Promise.all(
        response.data.vulns?.map((vuln: any) => this.convertOSVToVulnerability(vuln, packageName)) || []
      );

      // Cache results
      this.osvCache.set(cacheKey, { data: vulnerabilities, timestamp: Date.now() });

      return vulnerabilities;
    } catch (error) {
      console.error(`OSV API error for ${packageName}@${version}:`, error);
      return [];
    }
  }

  /**
   * Query GitHub Security Advisories
   */
  async queryGitHubAdvisories(packageName: string): Promise<Advisory[]> {
    const cacheKey = `github-${packageName}`;
    
    // Check cache first
    const cached = this.githubCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.config.cacheTimeout) {
      return cached.data;
    }

    try {
      const response = await axios.get(
        `https://api.github.com/advisories`,
        {
          params: {
            affects: packageName,
            per_page: 100
          },
          headers: {
            'Authorization': `Bearer ${this.config.githubToken}`,
            'Accept': 'application/vnd.github+json'
          },
          timeout: this.config.requestTimeout
        }
      );

      const advisories = response.data.map((advisory: any) => ({
        id: advisory.ghsa_id,
        summary: advisory.summary,
        description: advisory.description,
        severity: this.mapGitHubSeverity(advisory.severity),
        publishedAt: advisory.published_at,
        updatedAt: advisory.updated_at,
        references: advisory.references?.map((ref: any) => ref.url) || [],
        cvss: advisory.cvss?.score
      } as Advisory));

      // Cache results
      this.githubCache.set(cacheKey, { data: advisories, timestamp: Date.now() });

      return advisories;
    } catch (error) {
      console.error(`GitHub API error for ${packageName}:`, error);
      return [];
    }
  }

  /**
   * Query Snyk database for vulnerabilities
   */
  async querySnykDatabase(packageName: string, version: string): Promise<SnykVulnerability[]> {
    const cacheKey = `snyk-${packageName}-${version}`;
    
    // Check cache first
    const cached = this.snykCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.config.cacheTimeout) {
      return cached.data;
    }

    try {
      const response = await axios.get(
        `https://api.snyk.io/v1/test/npm/${packageName}/${version}`,
        {
          headers: {
            'Authorization': `token ${this.config.snykToken}`,
            'Content-Type': 'application/json'
          },
          timeout: this.config.requestTimeout
        }
      );

      const vulnerabilities = response.data.issues?.vulnerabilities?.map((vuln: any) => ({
        id: vuln.id,
        title: vuln.title,
        description: vuln.description,
        severity: this.mapSnykSeverity(vuln.severity),
        cvssScore: vuln.cvssScore,
        references: vuln.references || [],
        semver: vuln.semver
      } as SnykVulnerability)) || [];

      // Cache results
      this.snykCache.set(cacheKey, { data: vulnerabilities, timestamp: Date.now() });

      return vulnerabilities;
    } catch (error) {
      console.error(`Snyk API error for ${packageName}@${version}:`, error);
      return [];
    }
  }

  /**
   * Calculate CVSS score for a vulnerability
   */
  async calculateCVSS(vulnerability: Vulnerability): Promise<CVSSScore | null> {
    if (!vulnerability.cvssScore) {
      return null;
    }

    // This is a simplified CVSS calculation
    // In a real implementation, you'd parse the CVSS vector string
    return {
      version: '3.1',
      vectorString: 'N/A', // Would need to be parsed from vulnerability data
      baseScore: vulnerability.cvssScore,
      baseSeverity: vulnerability.severity
    };
  }

  /**
   * Prioritize vulnerabilities based on various factors
   */
  async prioritizeVulnerabilities(vulnerabilities: Vulnerability[]): Promise<PrioritizedVulnerability[]> {
    return vulnerabilities.map(vuln => {
      let priority = 0;
      let risk: RiskLevel = 'unknown';
      let recommendation = '';

      // Base priority on severity
      switch (vuln.severity) {
        case 'critical':
          priority = 100;
          risk = 'critical';
          recommendation = 'Update immediately';
          break;
        case 'high':
          priority = 75;
          risk = 'high';
          recommendation = 'Update as soon as possible';
          break;
        case 'medium':
          priority = 50;
          risk = 'medium';
          recommendation = 'Plan update in next release cycle';
          break;
        case 'low':
          priority = 25;
          risk = 'low';
          recommendation = 'Consider updating when convenient';
          break;
        case 'info':
          priority = 5;
          risk = 'low';
          recommendation = 'Monitor for updates';
          break;
      }

      // Adjust priority based on CVSS score
      if (vuln.cvssScore) {
        priority += Math.round(vuln.cvssScore * 2);
      }

      // Increase priority for recently published vulnerabilities
      const daysSincePublished = (Date.now() - vuln.publishedDate.getTime()) / (1000 * 60 * 60 * 24);
      if (daysSincePublished < 30) {
        priority += 10;
      }

      // Adjust recommendation based on fix availability
      if (vuln.fixedVersion) {
        recommendation += ` to version ${vuln.fixedVersion}`;
      } else {
        recommendation += ', no fix available yet';
        risk = 'high'; // Increase risk if no fix available
      }

      return {
        ...vuln,
        priority: Math.min(priority, 100),
        risk,
        recommendation
      } as PrioritizedVulnerability;
    }).sort((a, b) => b.priority - a.priority);
  }

  /**
   * Update CVE database (placeholder - would integrate with CVE feeds)
   */
  async updateCVEDatabase(): Promise<void> {
    // This would integrate with NIST NVD or other CVE feeds
    console.log('CVE database update not implemented - would sync with NIST NVD');
  }

  // Private helper methods

  private async getRepositoryPackages(repositoryId: string): Promise<PackageInfo[]> {
    try {
      const result = await this.db.selectFrom('dependency_graph')
        .select(['target_package', 'resolved_version', 'language'])
        .where('repository_id', '=', repositoryId)
        .where('dependency_type', '!=', 'transitive') // Focus on direct dependencies first
        .distinct()
        .execute();

      return result.map(row => ({
        name: row.target_package,
        version: row.resolved_version || 'latest',
        language: row.language as SupportedLanguage
      }));
    } catch (error) {
      console.error('Error getting repository packages:', error);
      return [];
    }
  }

  private async storeScanResults(
    packageName: string,
    version: string,
    language: SupportedLanguage,
    vulnerabilities: Vulnerability[]
  ): Promise<void> {
    try {
      const insertPromises = vulnerabilities.map(vuln =>
        this.db.insertInto('vulnerability_scan')
          .values({
            package_name: packageName,
            package_version: version,
            language: language,
            vulnerability_id: vuln.cveId || vuln.id,
            severity: vuln.severity,
            title: vuln.title,
            description: vuln.description,
            affected_versions: vuln.affectedVersions.join(', '),
            fixed_version: vuln.fixedVersion,
            published_date: vuln.publishedDate,
            modified_date: vuln.modifiedDate,
            source: 'vulnerability-scanner',
            references: JSON.stringify(vuln.references),
            repository_id: '' // Would need to be passed in
          })
          .onConflict((oc) => oc.columns(['package_name', 'package_version', 'vulnerability_id']).doUpdateSet({
            title: (eb) => eb.ref('excluded.title'),
            description: (eb) => eb.ref('excluded.description'),
            scan_date: new Date(),
            references: (eb) => eb.ref('excluded.references')
          }))
          .execute()
      );

      await Promise.all(insertPromises);
    } catch (error) {
      console.error('Error storing scan results:', error);
    }
  }

  private async storeRepositoryScanResult(result: RepositoryScanResult): Promise<void> {
    // Store summary in dependency_analysis_sessions table
    try {
      await this.db.insertInto('dependency_analysis_sessions')
        .values({
          repository_id: result.repositoryId,
          analysis_type: 'vulnerability',
          status: 'completed',
          completed_at: new Date(),
          duration_ms: result.scanDuration,
          packages_analyzed: result.packagesScanned,
          results_summary: JSON.stringify({
            totalVulnerabilities: result.vulnerabilities.length,
            ...result.summary,
            sources: result.sources
          })
        })
        .execute();
    } catch (error) {
      console.error('Error storing repository scan result:', error);
    }
  }

  private calculateSummary(vulnerabilities: Vulnerability[]) {
    return {
      criticalCount: vulnerabilities.filter(v => v.severity === 'critical').length,
      highCount: vulnerabilities.filter(v => v.severity === 'high').length,
      mediumCount: vulnerabilities.filter(v => v.severity === 'medium').length,
      lowCount: vulnerabilities.filter(v => v.severity === 'low').length,
      infoCount: vulnerabilities.filter(v => v.severity === 'info').length
    };
  }

  private deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const seen = new Set<string>();
    return vulnerabilities.filter(vuln => {
      const key = vuln.cveId || vuln.id;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  private async convertOSVToVulnerability(osvVuln: any, packageName: string): Promise<Vulnerability> {
    return {
      id: crypto.randomUUID(),
      cveId: osvVuln.aliases?.find((alias: string) => alias.startsWith('CVE-')),
      packageName,
      affectedVersions: osvVuln.affected?.flatMap((a: any) => 
        a.versions || a.ranges?.map((r: any) => r.events?.map((e: any) => e.introduced || e.fixed)).flat()
      ).filter(Boolean) || [],
      fixedVersion: osvVuln.database_specific?.fixed_version,
      severity: this.mapOSVSeverity(osvVuln.database_specific?.severity || 'UNKNOWN'),
      title: osvVuln.summary || 'Unknown vulnerability',
      description: osvVuln.details || '',
      references: osvVuln.references?.map((ref: any) => ref.url) || [],
      publishedDate: new Date(osvVuln.published || Date.now()),
      modifiedDate: osvVuln.modified ? new Date(osvVuln.modified) : undefined,
      cvssScore: osvVuln.severity?.find((s: any) => s.type === 'CVSS_V3')?.score
    };
  }

  private async convertAdvisoriesToVulnerabilities(
    advisories: Advisory[],
    packageName: string,
    version: string
  ): Promise<Vulnerability[]> {
    return advisories.map(advisory => ({
      id: crypto.randomUUID(),
      cveId: undefined, // GitHub advisories use GHSA IDs
      packageName,
      affectedVersions: [version], // Would need more parsing for actual affected versions
      fixedVersion: undefined, // Would need parsing from advisory
      severity: advisory.severity,
      title: advisory.summary,
      description: advisory.description,
      references: advisory.references,
      publishedDate: new Date(advisory.publishedAt),
      modifiedDate: new Date(advisory.updatedAt),
      cvssScore: advisory.cvss
    } as Vulnerability));
  }

  private async convertSnykToVulnerabilities(
    snykVulns: SnykVulnerability[],
    packageName: string,
    version: string
  ): Promise<Vulnerability[]> {
    return snykVulns.map(snykVuln => ({
      id: crypto.randomUUID(),
      cveId: undefined, // Snyk uses their own IDs
      packageName,
      affectedVersions: snykVuln.semver?.vulnerable || [version],
      fixedVersion: snykVuln.semver?.unaffected?.[0],
      severity: snykVuln.severity,
      title: snykVuln.title,
      description: snykVuln.description,
      references: snykVuln.references,
      publishedDate: new Date(), // Would need to get from Snyk API
      cvssScore: snykVuln.cvssScore
    } as Vulnerability));
  }

  private getOSVEcosystem(packageName: string): string {
    // Determine ecosystem based on package characteristics
    if (packageName.startsWith('@')) return 'npm';
    if (packageName.includes('/')) return 'Go';
    return 'npm'; // Default to npm
  }

  private mapOSVSeverity(osvSeverity: string): VulnerabilitySeverity {
    switch (osvSeverity.toUpperCase()) {
      case 'CRITICAL': return 'critical';
      case 'HIGH': return 'high';
      case 'MODERATE':
      case 'MEDIUM': return 'medium';
      case 'LOW': return 'low';
      default: return 'info';
    }
  }

  private mapGitHubSeverity(githubSeverity: string): VulnerabilitySeverity {
    switch (githubSeverity?.toLowerCase()) {
      case 'critical': return 'critical';
      case 'high': return 'high';
      case 'moderate': return 'medium';
      case 'low': return 'low';
      default: return 'info';
    }
  }

  private mapSnykSeverity(snykSeverity: string): VulnerabilitySeverity {
    switch (snykSeverity?.toLowerCase()) {
      case 'critical': return 'critical';
      case 'high': return 'high';
      case 'medium': return 'medium';
      case 'low': return 'low';
      default: return 'info';
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}