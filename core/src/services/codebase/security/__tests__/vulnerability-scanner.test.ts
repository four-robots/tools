/**
 * Vulnerability Scanner Tests
 * 
 * Tests for the VulnerabilityScanner service covering:
 * - OSV API integration
 * - GitHub Security Advisories
 * - Snyk integration
 * - Vulnerability prioritization
 * - Caching mechanisms
 */

import axios from 'axios';
import { DatabaseManager } from '../../../../utils/database.js';
import { VulnerabilityScanner } from '../vulnerability-scanner.js';
import type {
  Vulnerability,
  VulnerabilitySeverity,
  SupportedLanguage
} from '../../../../shared/types/codebase.js';

// Mock axios
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

// Mock database
jest.mock('../../../../utils/database.js');
const mockDb = {
  selectFrom: jest.fn().mockReturnValue({
    select: jest.fn().mockReturnValue({
      where: jest.fn().mockReturnValue({
        distinct: jest.fn().mockReturnValue({
          execute: jest.fn().mockResolvedValue([])
        })
      })
    })
  }),
  insertInto: jest.fn().mockReturnValue({
    values: jest.fn().mockReturnValue({
      onConflict: jest.fn().mockReturnValue({
        doUpdateSet: jest.fn().mockReturnValue({
          execute: jest.fn().mockResolvedValue({})
        })
      }),
      execute: jest.fn().mockResolvedValue({})
    })
  })
} as unknown as DatabaseManager;

describe('VulnerabilityScanner', () => {
  let scanner: VulnerabilityScanner;
  const mockConfig = {
    osvApiUrl: 'https://api.osv.dev',
    githubToken: 'test-github-token',
    snykToken: 'test-snyk-token',
    cacheTimeout: 3600000
  };

  beforeEach(() => {
    jest.clearAllMocks();
    scanner = new VulnerabilityScanner(mockDb, mockConfig);
  });

  describe('scanPackage', () => {
    it('should scan a package and return vulnerabilities', async () => {
      const mockOSVResponse = {
        data: {
          vulns: [
            {
              id: 'OSV-2023-001',
              summary: 'Test vulnerability',
              details: 'Detailed description',
              affected: [{
                versions: ['< 1.0.0'],
                ranges: [{ events: [{ introduced: '0' }, { fixed: '1.0.0' }] }]
              }],
              severity: [{ type: 'CVSS_V3', score: 7.5 }],
              published: '2023-01-01T00:00:00Z',
              modified: '2023-01-02T00:00:00Z',
              references: [{ url: 'https://example.com' }],
              aliases: ['CVE-2023-0001']
            }
          ]
        }
      };

      mockedAxios.post.mockResolvedValueOnce(mockOSVResponse);
      mockedAxios.get.mockResolvedValue({ data: [] }); // GitHub/Snyk empty responses

      const vulnerabilities = await scanner.scanPackage('test-package', '0.9.0', SupportedLanguage.TYPESCRIPT);

      expect(vulnerabilities).toHaveLength(1);
      expect(vulnerabilities[0].packageName).toBe('test-package');
      expect(vulnerabilities[0].title).toBe('Test vulnerability');
      expect(vulnerabilities[0].cveId).toBe('CVE-2023-0001');
      expect(vulnerabilities[0].cvssScore).toBe(7.5);
    });

    it('should handle OSV API errors gracefully', async () => {
      mockedAxios.post.mockRejectedValueOnce(new Error('OSV API error'));
      mockedAxios.get.mockResolvedValue({ data: [] });

      const vulnerabilities = await scanner.scanPackage('test-package', '1.0.0', SupportedLanguage.TYPESCRIPT);

      expect(vulnerabilities).toHaveLength(0);
    });

    it('should query GitHub Security Advisories when token provided', async () => {
      const mockGitHubResponse = {
        data: [
          {
            ghsa_id: 'GHSA-test-001',
            summary: 'GitHub Advisory',
            description: 'Test advisory from GitHub',
            severity: 'high',
            published_at: '2023-01-01T00:00:00Z',
            updated_at: '2023-01-02T00:00:00Z',
            references: [{ url: 'https://github.com/advisories/GHSA-test-001' }],
            cvss: { score: 8.0 }
          }
        ]
      };

      mockedAxios.post.mockResolvedValue({ data: { vulns: [] } }); // OSV empty
      mockedAxios.get
        .mockResolvedValueOnce(mockGitHubResponse) // GitHub advisories
        .mockResolvedValue({ data: { issues: { vulnerabilities: [] } } }); // Snyk empty

      const vulnerabilities = await scanner.scanPackage('test-package', '1.0.0', SupportedLanguage.TYPESCRIPT);

      expect(mockedAxios.get).toHaveBeenCalledWith(
        'https://api.github.com/advisories',
        expect.objectContaining({
          params: { affects: 'test-package', per_page: 100 },
          headers: expect.objectContaining({
            'Authorization': 'Bearer test-github-token'
          })
        })
      );

      expect(vulnerabilities).toHaveLength(1);
      expect(vulnerabilities[0].title).toBe('GitHub Advisory');
    });

    it('should query Snyk when token provided', async () => {
      const mockSnykResponse = {
        data: {
          issues: {
            vulnerabilities: [
              {
                id: 'SNYK-JS-TEST-001',
                title: 'Snyk vulnerability',
                description: 'Test vulnerability from Snyk',
                severity: 'medium',
                cvssScore: 5.5,
                references: ['https://snyk.io/vuln/SNYK-JS-TEST-001'],
                semver: {
                  vulnerable: ['< 2.0.0'],
                  unaffected: ['>= 2.0.0']
                }
              }
            ]
          }
        }
      };

      mockedAxios.post.mockResolvedValue({ data: { vulns: [] } }); // OSV empty
      mockedAxios.get
        .mockResolvedValueOnce({ data: [] }) // GitHub empty
        .mockResolvedValueOnce(mockSnykResponse); // Snyk vulnerabilities

      const vulnerabilities = await scanner.scanPackage('test-package', '1.0.0', SupportedLanguage.TYPESCRIPT);

      expect(mockedAxios.get).toHaveBeenCalledWith(
        'https://api.snyk.io/v1/test/npm/test-package/1.0.0',
        expect.objectContaining({
          headers: expect.objectContaining({
            'Authorization': 'token test-snyk-token'
          })
        })
      );

      expect(vulnerabilities).toHaveLength(1);
      expect(vulnerabilities[0].title).toBe('Snyk vulnerability');
    });

    it('should deduplicate vulnerabilities from different sources', async () => {
      const mockOSVResponse = {
        data: {
          vulns: [{
            id: 'OSV-2023-001',
            summary: 'Duplicate vulnerability',
            details: 'Description',
            aliases: ['CVE-2023-0001'],
            published: '2023-01-01T00:00:00Z'
          }]
        }
      };

      const mockGitHubResponse = {
        data: [{
          ghsa_id: 'GHSA-test-001',
          summary: 'Same vulnerability',
          description: 'Same CVE from GitHub',
          severity: 'high',
          published_at: '2023-01-01T00:00:00Z',
          updated_at: '2023-01-01T00:00:00Z',
          references: []
        }]
      };

      mockedAxios.post.mockResolvedValue(mockOSVResponse);
      mockedAxios.get
        .mockResolvedValueOnce(mockGitHubResponse)
        .mockResolvedValue({ data: { issues: { vulnerabilities: [] } } });

      // Mock convert methods to return same CVE ID
      jest.spyOn(scanner as any, 'convertOSVToVulnerability').mockResolvedValue({
        id: 'vuln-1',
        cveId: 'CVE-2023-0001',
        packageName: 'test-package',
        severity: 'high',
        title: 'Duplicate vulnerability'
      });

      jest.spyOn(scanner as any, 'convertAdvisoriesToVulnerabilities').mockResolvedValue([{
        id: 'vuln-2', 
        cveId: 'CVE-2023-0001',
        packageName: 'test-package',
        severity: 'high',
        title: 'Same vulnerability'
      }]);

      const vulnerabilities = await scanner.scanPackage('test-package', '1.0.0', SupportedLanguage.TYPESCRIPT);

      // Should be deduplicated to single vulnerability
      expect(vulnerabilities).toHaveLength(1);
    });
  });

  describe('batchScanPackages', () => {
    it('should scan multiple packages with rate limiting', async () => {
      const packages = [
        { name: 'pkg1', version: '1.0.0', language: SupportedLanguage.TYPESCRIPT },
        { name: 'pkg2', version: '2.0.0', language: SupportedLanguage.PYTHON },
        { name: 'pkg3', version: '1.5.0', language: SupportedLanguage.TYPESCRIPT }
      ];

      mockedAxios.post.mockResolvedValue({ data: { vulns: [] } });
      mockedAxios.get.mockResolvedValue({ data: [] });

      const results = await scanner.batchScanPackages(packages);

      expect(results).toHaveLength(3);
      expect(results[0].package.name).toBe('pkg1');
      expect(results[1].package.name).toBe('pkg2');
      expect(results[2].package.name).toBe('pkg3');
    });

    it('should handle individual package scan failures', async () => {
      const packages = [
        { name: 'good-pkg', version: '1.0.0', language: SupportedLanguage.TYPESCRIPT },
        { name: 'bad-pkg', version: '1.0.0', language: SupportedLanguage.TYPESCRIPT }
      ];

      mockedAxios.post
        .mockResolvedValueOnce({ data: { vulns: [] } }) // good-pkg succeeds
        .mockRejectedValueOnce(new Error('API error')); // bad-pkg fails

      mockedAxios.get.mockResolvedValue({ data: [] });

      const results = await scanner.batchScanPackages(packages);

      expect(results).toHaveLength(2);
      expect(results[0].package.name).toBe('good-pkg');
      expect(results[0].vulnerabilities).toHaveLength(0);
      expect(results[1].package.name).toBe('bad-pkg');
      expect(results[1].source).toBe('batch-scan-error');
    });
  });

  describe('scanRepository', () => {
    it('should scan entire repository and aggregate results', async () => {
      const mockPackages = [
        { name: 'express', version: '4.18.0', language: SupportedLanguage.TYPESCRIPT },
        { name: 'lodash', version: '4.17.21', language: SupportedLanguage.TYPESCRIPT }
      ];

      jest.spyOn(scanner as any, 'getRepositoryPackages').mockResolvedValue(mockPackages);

      const mockVulnerability: Vulnerability = {
        id: 'vuln-1',
        packageName: 'lodash',
        severity: 'high' as VulnerabilitySeverity,
        title: 'Prototype Pollution',
        description: 'Vulnerability in lodash',
        affectedVersions: ['< 4.17.12'],
        references: [],
        publishedDate: new Date(),
        cvssScore: 7.5
      };

      mockedAxios.post.mockResolvedValue({ data: { vulns: [] } });
      mockedAxios.get.mockResolvedValue({ data: [] });

      jest.spyOn(scanner, 'scanPackage')
        .mockResolvedValueOnce([]) // express - no vulns
        .mockResolvedValueOnce([mockVulnerability]); // lodash - one vuln

      const result = await scanner.scanRepository('test-repo');

      expect(result.repositoryId).toBe('test-repo');
      expect(result.totalPackages).toBe(2);
      expect(result.packagesScanned).toBe(2);
      expect(result.vulnerabilities).toHaveLength(1);
      expect(result.summary.highCount).toBe(1);
    });
  });

  describe('prioritizeVulnerabilities', () => {
    it('should prioritize vulnerabilities by severity and other factors', async () => {
      const vulnerabilities: Vulnerability[] = [
        {
          id: 'vuln-1',
          packageName: 'pkg1',
          severity: 'low' as VulnerabilitySeverity,
          title: 'Low severity vuln',
          description: 'Description',
          affectedVersions: [],
          references: [],
          publishedDate: new Date(Date.now() - 60 * 24 * 60 * 60 * 1000), // 60 days old
          cvssScore: 3.0
        },
        {
          id: 'vuln-2',
          packageName: 'pkg2', 
          severity: 'critical' as VulnerabilitySeverity,
          title: 'Critical vuln',
          description: 'Description',
          affectedVersions: [],
          fixedVersion: '2.0.0',
          references: [],
          publishedDate: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000), // 5 days old
          cvssScore: 9.5
        }
      ];

      const prioritized = await scanner.prioritizeVulnerabilities(vulnerabilities);

      expect(prioritized).toHaveLength(2);
      // Critical vulnerability should be first
      expect(prioritized[0].severity).toBe('critical');
      expect(prioritized[0].priority).toBeGreaterThan(prioritized[1].priority);
      expect(prioritized[0].risk).toBe('critical');
      expect(prioritized[0].recommendation).toContain('Update immediately');
    });

    it('should increase priority for recently published vulnerabilities', async () => {
      const recentVuln: Vulnerability = {
        id: 'vuln-recent',
        packageName: 'pkg',
        severity: 'medium' as VulnerabilitySeverity,
        title: 'Recent vuln',
        description: 'Description',
        affectedVersions: [],
        references: [],
        publishedDate: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000), // 10 days old
        cvssScore: 5.0
      };

      const oldVuln: Vulnerability = {
        id: 'vuln-old',
        packageName: 'pkg',
        severity: 'medium' as VulnerabilitySeverity,
        title: 'Old vuln',
        description: 'Description',
        affectedVersions: [],
        references: [],
        publishedDate: new Date(Date.now() - 200 * 24 * 60 * 60 * 1000), // 200 days old
        cvssScore: 5.0
      };

      const prioritized = await scanner.prioritizeVulnerabilities([oldVuln, recentVuln]);

      // Recent vulnerability should have higher priority
      expect(prioritized[0].id).toBe('vuln-recent');
      expect(prioritized[0].priority).toBeGreaterThan(prioritized[1].priority);
    });
  });

  describe('caching', () => {
    it('should cache OSV API responses', async () => {
      const mockResponse = { data: { vulns: [] } };
      mockedAxios.post.mockResolvedValue(mockResponse);
      mockedAxios.get.mockResolvedValue({ data: [] });

      // First call
      await scanner.scanPackage('cached-pkg', '1.0.0', SupportedLanguage.TYPESCRIPT);
      expect(mockedAxios.post).toHaveBeenCalledTimes(1);

      // Second call should use cache
      await scanner.scanPackage('cached-pkg', '1.0.0', SupportedLanguage.TYPESCRIPT);
      expect(mockedAxios.post).toHaveBeenCalledTimes(1); // No additional calls
    });

    it('should respect cache timeout', async () => {
      const shortCacheScanner = new VulnerabilityScanner(mockDb, {
        ...mockConfig,
        cacheTimeout: 100 // 100ms
      });

      mockedAxios.post.mockResolvedValue({ data: { vulns: [] } });
      mockedAxios.get.mockResolvedValue({ data: [] });

      // First call
      await shortCacheScanner.scanPackage('pkg', '1.0.0', SupportedLanguage.TYPESCRIPT);
      expect(mockedAxios.post).toHaveBeenCalledTimes(1);

      // Wait for cache to expire
      await new Promise(resolve => setTimeout(resolve, 150));

      // Second call should make new request
      await shortCacheScanner.scanPackage('pkg', '1.0.0', SupportedLanguage.TYPESCRIPT);
      expect(mockedAxios.post).toHaveBeenCalledTimes(2);
    });
  });

  describe('error handling', () => {
    it('should handle network timeouts', async () => {
      const timeoutError = new Error('timeout');
      timeoutError.name = 'ETIMEDOUT';
      
      mockedAxios.post.mockRejectedValue(timeoutError);
      mockedAxios.get.mockResolvedValue({ data: [] });

      const vulnerabilities = await scanner.scanPackage('pkg', '1.0.0', SupportedLanguage.TYPESCRIPT);

      expect(vulnerabilities).toHaveLength(0);
    });

    it('should handle malformed API responses', async () => {
      mockedAxios.post.mockResolvedValue({ data: null });
      mockedAxios.get.mockResolvedValue({ data: [] });

      const vulnerabilities = await scanner.scanPackage('pkg', '1.0.0', SupportedLanguage.TYPESCRIPT);

      expect(vulnerabilities).toHaveLength(0);
    });

    it('should handle missing authentication tokens gracefully', async () => {
      const noTokenScanner = new VulnerabilityScanner(mockDb, {
        osvApiUrl: 'https://api.osv.dev'
        // No GitHub or Snyk tokens
      });

      mockedAxios.post.mockResolvedValue({ data: { vulns: [] } });

      const vulnerabilities = await noTokenScanner.scanPackage('pkg', '1.0.0', SupportedLanguage.TYPESCRIPT);

      expect(vulnerabilities).toHaveLength(0);
      expect(mockedAxios.get).not.toHaveBeenCalled(); // GitHub/Snyk not queried
    });
  });

  describe('database integration', () => {
    it('should store scan results in database', async () => {
      mockedAxios.post.mockResolvedValue({ data: { vulns: [] } });
      mockedAxios.get.mockResolvedValue({ data: [] });

      await scanner.scanPackage('pkg', '1.0.0', SupportedLanguage.TYPESCRIPT);

      expect(mockDb.insertInto).toHaveBeenCalledWith('vulnerability_scan');
    });

    it('should handle database errors gracefully', async () => {
      mockedAxios.post.mockResolvedValue({ data: { vulns: [] } });
      mockedAxios.get.mockResolvedValue({ data: [] });

      (mockDb.insertInto as jest.Mock).mockImplementation(() => {
        throw new Error('Database error');
      });

      // Should not throw, but log error
      const vulnerabilities = await scanner.scanPackage('pkg', '1.0.0', SupportedLanguage.TYPESCRIPT);
      expect(vulnerabilities).toHaveLength(0);
    });
  });

  describe('severity mapping', () => {
    it('should correctly map OSV severity levels', async () => {
      const testCases = [
        { osvSeverity: 'CRITICAL', expected: 'critical' },
        { osvSeverity: 'HIGH', expected: 'high' },
        { osvSeverity: 'MODERATE', expected: 'medium' },
        { osvSeverity: 'MEDIUM', expected: 'medium' },
        { osvSeverity: 'LOW', expected: 'low' },
        { osvSeverity: 'UNKNOWN', expected: 'info' }
      ];

      for (const testCase of testCases) {
        const result = (scanner as any).mapOSVSeverity(testCase.osvSeverity);
        expect(result).toBe(testCase.expected);
      }
    });

    it('should correctly map GitHub severity levels', async () => {
      const testCases = [
        { githubSeverity: 'critical', expected: 'critical' },
        { githubSeverity: 'high', expected: 'high' },
        { githubSeverity: 'moderate', expected: 'medium' },
        { githubSeverity: 'low', expected: 'low' },
        { githubSeverity: undefined, expected: 'info' }
      ];

      for (const testCase of testCases) {
        const result = (scanner as any).mapGitHubSeverity(testCase.githubSeverity);
        expect(result).toBe(testCase.expected);
      }
    });

    it('should correctly map Snyk severity levels', async () => {
      const testCases = [
        { snykSeverity: 'critical', expected: 'critical' },
        { snykSeverity: 'high', expected: 'high' },
        { snykSeverity: 'medium', expected: 'medium' },
        { snykSeverity: 'low', expected: 'low' },
        { snykSeverity: null, expected: 'info' }
      ];

      for (const testCase of testCases) {
        const result = (scanner as any).mapSnykSeverity(testCase.snykSeverity);
        expect(result).toBe(testCase.expected);
      }
    });
  });
});